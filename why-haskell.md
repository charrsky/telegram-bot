# Почему именно Haskell


Предыстория. До этого мы довольно много разрабатывали на JavaScript (фронт с
React и бек на Node.JS, +Typescript), Python (плюс Django), Elixir
(присахаренный Erlang), у многих ребят из команды есть опыт с C/C++/C#. Однако в
каждом языке есть свои недостатки, а у нас довольно высокие требования к тому,
чтобы язык позволял быстро написать бизнес-логику, которую было бы легко понять
коллегам и поддерживать. Именно требование легкой поддержки и надежности у нас
всегда были в приоритете.

Haskell — чистый функциональный язык с ленивой моделью вычислений и статической
типизацией. Причины, почему мы выбрали именно этот язык:

Haskell имеет, пожалуй, самую мощную систему типов среди промышленных языков на
данный момент Haskell — единственный язык, на котором можно спокойно писать
коммерческий софт, и который при этом позволяет четко отделять [чистые части
программы](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
от [частей с
сайд-эффектами](https://en.wikipedia.org/wiki/Side_effect_(computer_science)). У
Haskell уникальная экосистема, предлагающая не просто паттерны, а формальные
абстракции (такие, как функторы и монады), которые на данный момент хорошо
изучены в научной сфере, которые легко комбинировать, и которые позволяют
описать огромное количество разного рода взаимосвязей между частями программы.

Haskell, несмотря на свои академические зачатки, очень хорош в продакшене (и
куча тому примеров дана ниже), он быстр, у него отличный механизм для
concurrency, его поддерживают почти все популярные редакторы кода и для него
есть огромное количество программ, помогающих нам: repl, линтеры, форматтеры и
тд. Также в плюсы можно добавить колоссальную выразительность языка и его
гибкость (например, операторы можно использовать, как в инфиксной, так и в
префиксной записи, а также определять свои:
https://wiki.haskell.org/Infix_operator). И один из главных бонусов, которые
вытекают из всего вышеперечисленного, и который нас очень сильно приманил —
легкость рефакторинга. Коммерческая разработка лишь на 10-15% состоит из
написания абсолютно нового функционала, чаще же это либо добавление чего-то к
уже существующим частям, либо рефакторинг после того, как опыт показал, где были
ошибки в проектировании. На рефакторинг всегда нужно делать ставку, если
планируется долгое развитие проекта (а нашему проекту уже почти два года, и он
продолжает активно разрастаться), с Haskell же мы имеем кодовую базу, которая
если скомпилировалась, то с 90-95% вероятностью она работает корректно. А значит
во время рефакторинга компилятор сам будет за нас делать самую грязную работу —
находить регресионные ошибки, замечать упущенные по невнимательности детали,
помогать проектировать стройную систему (так как закрыть костылем, как можно
было бы это сделать в Python, тут уже нельзя).

Куча примеров использования [Haskell в продакшене](https://haskellcosm.com/).

Два списка компаний, использующих Haskell в продакшене:
<https://wiki.haskell.org/Haskell_in_industry> и
<https://gist.github.com/sigrlami/769f5e6674adbd399f00>.

Плюс еще более конкретные описания (это только быстро вспомнившиеся, еще много
примеров можно нагуглить):
- Facebook борется со спамом с помощью Хаскеля и напилили опенсорсную либу:
  https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
- Github написали Semantic на Haskell, [читать подробности о выборе
  языка](https://github.com/github/semantic/blob/7364e164947116406850ff6f298d80ba77105229/docs/why-haskell.md).
- [Haskell в большом трейдинговом
  проекте](https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems).

Конечно, есть и свои недостатки, которые мы отлично понимаем, и с которыми
готовы были смириться: высокий порог входа (хотя, возможно, и не сильно выше тех
же C++ или C#, если изучать их с нуля), отсутствие единого гайдлайна с best
practices, отсутствие мощных IDE (хотя они и не особо нужны при таком выводе
типов и таком компиляторе, который и так все подскажет, если правильно
спросить).

Еще недостатки, на которые нам пофиг: экосистема не изобилует монструозными
фреймворками и разного рода "энтерпрайзными" библиотеками, хотя нам конкретно
это совсем не мешает, так как все равно фреймворки блистают лишь в задачах
уровня "сходить в базу, вытащить из базы, показать в html/json/xml", а у нас же
много бизнес-логики, которую никакая библиотека за нас не напишет.

Все это можно подытожить простым выводом — будь у нас простенький проект с адски
малыми сроками, то Haskell был бы не лучшим выбором. Но наш проект долгоживущий
и активно разрастающийся, а значит нам нужен язык, который бы позволял писать
максимально прозрачный и понятный код, который можно легко поддерживать и
рефакторить. Функциональный, чистый, статически типизированный Haskell как
нельзя лучше подходит на эту роль, поэтому мы его и выбрали.

Опционально: [выводы других опытных разработчиков после нескольких лет работы на Haskell](https://ru.hexlet.io/blog/posts/haskell-yazyk-pozvolyayuschiy-glubzhe-ponyat-programmirovanie-kak-on-ustroen-i-pochemu-ego-vybirayut-razrabotchiki?utm_source=telegram&utm_medium=social&utm_campaign=mdtruehaskell--funktsionalnyy-yazyk).
