# Learn Haskell with MetaLamp

## Про трудоустройство


По любым вопросам по программе обучения пишите Светлане в Telegram:
@Lana_Dulceva.

Внимательно прочитайте введение и правила по работе во время программы.

Проходить программу обучения вы можете из любого уголка нашей страны, работать в
дальнейшем тоже можно удалённо. Но если вы проживаете в Томске — у вас есть
возможность посещать офис.

Обучение бесплатное и доступно всем. Но трудоустройство в нашу команду возможно
только для граждан РФ. Поэтому и пятый этап обучения (код-ревью) доступен только
для граждан РФ.


## Intro


Заданий по Haskell: 5. Они довольно объемные, даже при усиленном прохождении это
займет около 5 месяцев. Формат задач нацелен на то, чтобы системно и по порядку
изучать основы и принципы разработки. Мы считаем, что очень грубая ошибка при
изучении — кинуться в омут реальных практических задач и штудировать кучу
конкретных высокоуровневых технологий (веб-фреймворки, как отличный пример, где
помимо языка еще столько же времени надо потратить на изучение документации
самого фреймворка). Мы сторонники того, что без фундаментальных знаний в
технологии лучше не лезть :) Поэтому базис — сам язык, основные паттерны и
принципы архитектуры. Далее самые базовые технологии (простейшие веб-сервера,
простейшие обертки для работы с базами данных и тд). Ну а на выходе - большой
рефакторинг на основе кучи разных источников и проверка нами ваших
github-репозиториев с созданием issues.

Также мы сторонники подхода, при котором новичков нельзя ставить на реальные
проекты, пока они не сделали несколько своих средних проектов минимум на 2-3
тысячи строк. Если сразу подключаться к реальным проектам, то есть огромный риск
утонуть в чужом и непонятном легаси, потерять мотивацию, но главное — получить
несистемный, очень отрывистый опыт, так как задачи будут довольно
узконаправленные и кривая обучения будет неоднородной. В итоге, даже если стажер
не растеряет всю мотивацию, его опыт за тот же промежуток времени будет гораздо
слабее, чем у коллеги, который системно с нуля делал парочку своих проектов.

В целом это должно быть отличной стажировкой для вас, мы готовы с радостью
отвечать на ваши вопросы (задавайте их в блипах под описанием каждого задания),
а сами задания мы постарались сделать такими, чтобы на выходе у вас был максимум
полезных практических и теоретических знаний. Еще нам бы очень хотелось видеть,
как вы сами кооперируетесь друг с другом и решаете вместе возникающие проблемы.
На вашу коммуникацию мы тоже будем обращать внимание - в первую очередь мы
ожидаем увидеть в вас приветливого хорошего человека, с которым приятно
совместно работать по 8 часов в день минимум :)

Здесь же вы можете найти другие полезные материалы по программе обучения:

1) [FAQ по программе обучения для первого этапа](employment-faq.md).


## Почему именно Haskell


Предыстория. До этого мы довольно много разрабатывали на JavaScript (фронт с
React и бек на Node.JS, +Typescript), Python (плюс Django), Elixir
(присахаренный Erlang), у многих ребят из команды есть опыт с C/C++/C#. Однако в
каждом языке есть свои недостатки, а у нас довольно высокие требования к тому,
чтобы язык позволял быстро написать бизнес-логику, которую было бы легко понять
коллегам и поддерживать. Именно требование легкой поддержки и надежности у нас
всегда были в приоритете.

Haskell — чистый функциональный язык с ленивой моделью вычислений и статической
типизацией. Причины, почему мы выбрали именно этот язык:

Haskell имеет, пожалуй, самую мощную систему типов среди промышленных языков на
данный момент Haskell — единственный язык, на котором можно спокойно писать
коммерческий софт, и который при этом позволяет четко отделять [чистые части
программы](https://ru.wikipedia.org/wiki/%D0%A7%D0%B8%D1%81%D1%82%D0%BE%D1%82%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
от [частей с
сайд-эффектами](https://en.wikipedia.org/wiki/Side_effect_(computer_science)). У
Haskell уникальная экосистема, предлагающая не просто паттерны, а формальные
абстракции (такие, как функторы и монады), которые на данный момент хорошо
изучены в научной сфере, которые легко комбинировать, и которые позволяют
описать огромное количество разного рода взаимосвязей между частями программы.

Haskell, несмотря на свои академические зачатки, очень хорош в продакшене (и
куча тому примеров дана ниже), он быстр, у него отличный механизм для
concurrency, его поддерживают почти все популярные редакторы кода и для него
есть огромное количество программ, помогающих нам: repl, линтеры, форматтеры и
тд. Также в плюсы можно добавить колоссальную выразительность языка и его
гибкость (например, операторы можно использовать, как в инфиксной, так и в
префиксной записи, а также определять свои:
https://wiki.haskell.org/Infix_operator). И один из главных бонусов, которые
вытекают из всего вышеперечисленного, и который нас очень сильно приманил —
легкость рефакторинга. Коммерческая разработка лишь на 10-15% состоит из
написания абсолютно нового функционала, чаще же это либо добавление чего-то к
уже существующим частям, либо рефакторинг после того, как опыт показал, где были
ошибки в проектировании. На рефакторинг всегда нужно делать ставку, если
планируется долгое развитие проекта (а нашему проекту уже почти два года, и он
продолжает активно разрастаться), с Haskell же мы имеем кодовую базу, которая
если скомпилировалась, то с 90-95% вероятностью она работает корректно. А значит
во время рефакторинга компилятор сам будет за нас делать самую грязную работу —
находить регресионные ошибки, замечать упущенные по невнимательности детали,
помогать проектировать стройную систему (так как закрыть костылем, как можно
было бы это сделать в Python, тут уже нельзя).

Куча примеров использования [Haskell в продакшене](https://haskellcosm.com/).

Два списка компаний, использующих Haskell в продакшене:
<https://wiki.haskell.org/Haskell_in_industry> и
<https://gist.github.com/sigrlami/769f5e6674adbd399f00>.

Плюс еще более конкретные описания (это только быстро вспомнившиеся, еще много
примеров можно нагуглить):
- Facebook борется со спамом с помощью Хаскеля и напилили опенсорсную либу:
  https://code.facebook.com/posts/302060973291128/open-sourcing-haxl-a-library-for-haskell/
- Github написали Semantic на Haskell, [читать подробности о выборе
  языка](https://github.com/github/semantic/blob/7364e164947116406850ff6f298d80ba77105229/docs/why-haskell.md).
- [Haskell в большом трейдинговом
  проекте](https://skillsmatter.com/skillscasts/9098-haskell-in-the-large-the-day-to-day-practice-of-using-haskell-to-write-large-systems).

Конечно, есть и свои недостатки, которые мы отлично понимаем, и с которыми
готовы были смириться: высокий порог входа (хотя, возможно, и не сильно выше тех
же C++ или C#, если изучать их с нуля), отсутствие единого гайдлайна с best
practices, отсутствие мощных IDE (хотя они и не особо нужны при таком выводе
типов и таком компиляторе, который и так все подскажет, если правильно
спросить).

Еще недостатки, на которые нам пофиг: экосистема не изобилует монструозными
фреймворками и разного рода "энтерпрайзными" библиотеками, хотя нам конкретно
это совсем не мешает, так как все равно фреймворки блистают лишь в задачах
уровня "сходить в базу, вытащить из базы, показать в html/json/xml", а у нас же
много бизнес-логики, которую никакая библиотека за нас не напишет.

Все это можно подытожить простым выводом — будь у нас простенький проект с адски
малыми сроками, то Haskell был бы не лучшим выбором. Но наш проект долгоживущий
и активно разрастающийся, а значит нам нужен язык, который бы позволял писать
максимально прозрачный и понятный код, который можно легко поддерживать и
рефакторить. Функциональный, чистый, статически типизированный Haskell как
нельзя лучше подходит на эту роль, поэтому мы его и выбрали.

Опционально: [выводы других опытных разработчиков после нескольких лет работы на Haskell](https://ru.hexlet.io/blog/posts/haskell-yazyk-pozvolyayuschiy-glubzhe-ponyat-programmirovanie-kak-on-ustroen-i-pochemu-ego-vybirayut-razrabotchiki?utm_source=telegram&utm_medium=social&utm_campaign=mdtruehaskell--funktsionalnyy-yazyk).


## Первое задание: теория


Изучить:

- Для начала минимум, необходимый для написания самых простых проектов: [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/chapters).

- Параллельно выполнять каты из [Codewars](https://www.codewars.com/kata/search/haskell).

  Ниже обязательные для прохождения каты. Они примерно отсортированы от легких к
  сложным, выбирайте сами подходящий момент, когда начинать их делать (но по
  большей части после 6 главы Learn you a Haskell можно смело браться за первые
  задания):

  1. [Is this a triangle](https://www.codewars.com/kata/is-this-a-triangle)

     Определение, могут ли данных три числа быть длинами сторон треугольника.

     С этой катой тренируются базовые логические конструкции. Полезно, что есть
     простор и для элегантных решений, и для решений "в лоб".

     Есть вероятность, что практикующий потренирует так же совсем базовую работу
     со списками (хотя тут это необязательно).

  2. [Disemvowel trolls](https://www.codewars.com/kata/disemvowel-trolls)

     Задача на удаление всех гласных (почти) из строки.

     Позволяет закрепить отношение к строкам, как к списку символов,
     тренирует работу со списками, особенно базовые навыки фильтрации. Ката
     была выбрана в том числе из-за интересного оформления самой задачи и
     конкретного use case, где нужно защищаться от кричащих троллей :)

  3. [Highest and lowest](https://www.codewars.com/kata/highest-and-lowest)

     Найти самое большое и самое маленькое значение из строки чисел, которую
     надо предварительно распарсить.

     Отличная задача для начального уровня, позволяет натренировать парсинг
     инстансов Read и самую базовую работу со списками (на поиск наименьшего
     и наибольшего значений). Естественно, и то, и другое, будет полезно уже
     при решении реальных задач.

  4. [Isograms](https://www.codewars.com/kata/isograms/)

     Задача на вычисление дубликатов в массиве. Это наглядный экземпляр
     стандартного алгоритмического задания, которое в разных вариациях часто
     встречается в упражнениях почти на всех языках. Здесь же можно
     опробовать её на Хаскеле и сравнить (на деле или интуитивно) с тем, как
     бы это решалось на остальных языках.

     Как и почти во всех классических задачах, тут есть простор для фантазии,
     несмотря на простоту описания. Можно решать как банальными
     конструкциями, а можно попытаться найти что-то изящное :)

  5. [Split strings](https://www.codewars.com/kata/split-strings)

     Задача с предельно простым описанием, очень ясным примером, но которая
     не такая очевидная в решении. Хорошо иллюстрирует работы с
     паттерн-матчингом и конструированием списков, которые тут приходится то
     разбирать, то собирать. Ну и, естественно, отличная тренировка самой
     базовой рекурсии.

  6. [Tribonacci sequence](https://www.codewars.com/kata/tribonacci-sequence)

     Интересная вариация набившей оскомину задачи про ряд Фибоначчи. Очень
     простое с виду изменение правил игры заставляет призадуматься. Ката
     отлично тренирует конструирование списков и рекурсию, либо умение
     обходиться без рекурсии стандартными функциями высшего порядка :)

  7. [Title case](https://www.codewars.com/kata/title-case)

     Кульминация базовых тренировок, где необходимо уметь работать и с
     символами, и со строками, и со списками. Задача, которая действительно
     может встретиться в боевых условиях, и которая позволит показать навыки
     написания "читаемого" кода. Здесь есть возможность, как для явной
     рекурсии, так и для использования стандартных функций высшего порядка,
     есть интересное требование замены буквы на заглавный аналог и условие,
     когда вообще ничего делать не надо :)

- Обязательно попробуйте найти и пройти от 3-х кат самостоятельно! Также
  публикуем список дополнительных кат от тех, кто проходил обучение до вас) Все
  это не обязательно к выполнению, это просто для вашего собственного развития.
  Список будет дополняться. :)

  1. [Dubstep](https://www.codewars.com/kata/dubstep/)

     Позволяет ещё немного потренироваться работать со списками. Можно написать
     рекурсивное решение, либо попробовать работать со свёртками, либо просто
     глубже поковырять стандартную библиотеку и найти в ней функции, позволяющие
     легко справиться с задачей.

  2. [Valid braces](https://www.codewars.com/kata/5277c8a221e209d3f6000b56)

     Нужно проверить все ли скобки в выражении закрываются. Можно решать разными
     способами.

     Она заставляет задуматься, что является аналогом стека в хаскеле, и
     тренирует навыки обращения со свертками.

  3. [Product of consecutive Fib numbers](https://www.codewars.com/kata/5541f58a944b85ce6d00006a)

     Нужно найти является ли переданное число произведением соседних чисел в
     последовательности Фибоначчи.

     Задача тренирует навыки создания рекурсии, или обращения с функциями из
     `Data.List`.

  4. [Reverse words](https://www.codewars.com/kata/reverse-words)

     Перевернуть все слова по отдельности. Пробелы оставить как есть. У этой
     каты есть красивое решение с использованием комбинатора из Data.Function.
     Будет полезно познакомиться с этим модулем.

  5. [Snail](https://www.codewars.com/kata/snail/haskell)

     Интересная с задача с простым условием, для которой сразу понятен
     императивный алгоритм с вложенными циклами, но не сразу — функциональный.

     Помечена как 4-ый кью, но на самом деле достаточно первых глав LYAH и
     умения работать со списками.

  6. [Equal sides of array](https://www.codewars.com/kata/equal-sides-of-an-array/train/haskell)

     В задаче нужно найти индекс элемента в списке, где сумма элементов списка
     слева будет равна сумме элементов списка справа от найденного элемента.
     Если же такого элемента нет, то вывести -1.

     В этой кате можно отработать работу со списками, поискать вспомогательные
     функции в модуле Data.List или же просто посмотреть интересные решение
     других людей.

  7. [Go so far around to the right that you end up left](https://www.codewars.com/kata/5424e78460d77749f2000279)

     Необходимо реализовать левую свертку через правую. Для решения нужно
     ознакомиться с реализацией обеих сверток и хорошо понимать, как работает
     каждая из них.

     Для решения нужно хорошо разобраться в принципе работы обеих сверток, так
     как использовать reverse = читерить.

  8. [Take a Ten Minute Walk](https://www.codewars.com/kata/54da539698b8a2ad76000228)

     Нужно проверить предложенный маршрут (движение по сторонам света) на два
     условия: длительность (10 минут при минуте на одно перемещение) и
     совпадение начальной и конечной точки (вернуться туда, откуда пришёл).

     Тренирует работу со списками или использование `Data.List`.

  9. [Highest Rank Number in an Array](https://www.codewars.com/kata/5420fc9bb5b2c7fd57000004/haskell)

     Небольшая ката для практики бесточечного стиля и работы со стандартными
     модулями типа `Data.List`, `Data.Ord` и т.д. на ваш выбор.

  10. [Duplicate Encoder](https://www.codewars.com/kata/54b42f9314d9229fd6000d9c)

      Простая ката, нацеленная на поиск дубликатов в массиве, что часто
      встречается в реальных задачах.

  11. [Next bigger number with the same digits](https://www.codewars.com/kata/55983863da40caa2c900004e)

      Ката с очевидным брутфорс-решением. Попытайтесь найти наиболее оптимальный
      алгоритм, потому как если написать слишком просто, то все тесты пройти не
      успеет.

  12. [Find The Parity Outlier](https://www.codewars.com/kata/5526fc09a1bbd946250002dc/haskell)

      У FindOutlier множестово разных решений функциями из Data.List, или можно
      в лоб, сверткой, тренирует паттерн матчинг и функции как объекты первого
      класса.

  13. [Most frequently used words in a text](https://www.codewars.com/kata/51e056fe544cf36c410000fb/haskell)

      Достаточно простая ката для 4 кью. Тренирует обработку строки с
      использованием `Data.Char` и `Data.List`.

  14. [Fibonacci, Tribonacci and friends](https://www.codewars.com/kata/556e0fccc392c527f20000c5/haskell)

      Логическое продолжение каты Tribonacci, достаточно интересное и
      неординарное решение, тренирует мозги.

  15. [Sortable Shapes](https://www.codewars.com/kata/586669a8442e3fc307000048)

      Это простая ката 6 кью (30 минут на решение достаточно) позволит Вам
      потренироваться в создании пользовательского типа данных. Основной
      результат - это понимание реализации каких классов нужно предусмотреть для
      созданного типа, чтобы данные могли отправляться в функцию `sort`.

  16. [Recurrence relations](https://www.codewars.com/kata/recurrence-relations/haskell)

  17. [Simple Fun #74: Growing Plant](https://www.codewars.com/kata/58941fec8afa3618c9000184)

  18. [Coloured Triangles](https://www.codewars.com/kata/coloured-triangles)

  19. [Digital Root](https://www.codewars.com/kata/541c8630095125aba6000c00)

  20. [Twice linear](https://www.codewars.com/kata/5672682212c8ecf83e000050/train/haskell)

  21. [Playing with laziness](https://www.codewars.com/kata/5516b80d891547c9b50007fd/haskell)

  22. [Break camelCase](https://www.codewars.com/kata/5208f99aee097e6552000148)

  23. [CamelCase Method](https://www.codewars.com/kata/587731fda577b3d1b0001196)

  24. [Speed Control](https://www.codewars.com/kata/speed-control/haskell)

- После того, как изучены вышеназванные источники, можно одновременно выполнять
  дальнейшие задания и понемногу изучать следующие ресурсы

  - Обязательно: системное описание почти всех самых популярных тайпклассов —
    [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia).

  - Обязательно: учебник чуть более глубоко описывающий Haskell —
    <https://anton-k.github.io/ru-haskell-book/book/home.html>.

    Позволяет понять многие теоретические моменты. Обязательны к прочтению
    главы 1-9, остальные по желанию.

  - Обязательно: видео-курс на степик от Дениса Москвина.

    https://stepik.org/course/75/ — первая часть курса, очень системный и
    развернутый материал по Haskell. Она обязательна к изучению.

    https://stepik.org/course/693/ - 2-я часть курса, она уже необязательна.
    Материал тут достаточно сложный, его рекомендуем изучать после того, как
    сделаны первые версии бота и сервера, чтобы закрепить полученные на
    практике знания и расширить/углубить их.

  - Очень рекомендуется: книга для начинающих с хорошим практическим уклоном
    Get Programming with Haskell (W. Kurt).

    Т.к. эта книга не доступна бесплатно, мы не включили её в обязательную
    часть, но очень рекомендуем. Здесь есть очень приближенные к реальным
    задачи, с помощью которых вы можете быстро и эффективно начать писать свои
    приложения, вроде бота. Книга максимально свежая и актуальная, хорошо
    написана. Практика показала, что изучающие её в рамках нашей программы
    потом её активно хвалили :)

  - По желанию: сделать упражнения из глав [Real World
    Haskell](http://book.realworldhaskell.org/), которые помогут освоиться с
    приближенными к реальным задачам.

  - По желанию: часто рекомендуемая многими новичками книга
    <http://haskellbook.com/>.

  - По желанию: [видео-курс от Николая
    Кудасова](https://www.youtube.com/watch?v=jNQVa5INdDk&list=PLov3NSwpY86cfkfXyVroSZkHemxoAdnrd&index=1).

  - По желанию: Write Yourself a Scheme in 48 Hours.

    Упражнение по написанию простого интерпретатора для языка Scheme (язык, с которого был слизан JavaScript).
    <https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours>.

    Есть так же перевод на русский (там могут быть не все части или
    неактуальные данные):
    <https://ru.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours>.

    Очень рекомендую пройти, на самом деле туториал довольно небольшой, но
    дает хороший пример написания средних по размеру програм, в то время как
    почти все остальные туториалы нацелены на примеры совсем тривиальных вещей
    в один-два файла.

- [Выводы и ссылки на рецензии о современных книгах по Haskell](https://medium.com/@_bravit/книги-по-программированию-на-haskell-выводы-712c1f5b7749).

- Статьи по различным темам, которые могут оказаться полезными для понимания
  того или иного материала

    - [Pitfalls in Haskell](http://web.archive.org/web/20150505013645/http://users.jyu.fi:80/~sapekiis/haskell-pitfalls/)
    - [Thinking Functionally with Haskell](https://pragprog.com/magazines/2012-09/thinking-functionally-with-haskell)
    - [Функторы, монады и аппликативы в картинках](https://habr.com/post/183150/)
    - [Три полезные монады (в картинках)](https://habr.com/post/184722/)
    - [«Страшные» абстракции Haskell без математики и без кода (почти). Часть I](https://habr.com/post/272115/)
    - [Моноиды, полугруппы и все-все-все](https://habr.com/company/jugru/blog/340178/). Оригинал [тут](http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/)

**Важное требование — отчеты**. При прохождении этого и следующих заданий мы будем ждать от вас отчетов с текущим прогрессом и вашим личным отношением к изученному/сделанному. Отчеты лучше писать под конец дня, когда что-то делали (ну или в начале следующего), настолько часто, насколько вы будете работать. График у нас гибкий, так что можно спокойно делать любые перерывы в отправке отчетов и в любой момент возвращаться и писать их снова.

Отчеты шлем в телеграм в общую группу: <https://t.me/learn_haskell_with_fsd>.
**ВАЖНО!** После входа в группу нужно нажать на кнопку “Я не бот”, иначе вас выкинет из группы.

Там же можно спрашивать совета, самим помогать и узнавать о новостях нашей программы обучения. Формат неформальный, пишите, как душа пожелает, чем больше личного фидбека, тем лучше!


## Второе задание: задачки по языку


https://www.schoolofhaskell.com/user/DanBurton/20-intermediate-exercises

И выполнить следующие каты:

- Обязательные для прохождения:

  1. [Бесконечные структуры](https://www.codewars.com/kata/functional-streams)

  2. [Создание своих инстансов для 5 базовых монад](https://www.codewars.com/kata/five-fundamental-monads)

  3. [Монадный стек Maybe + List + State](https://www.codewars.com/kata/escape-the-mines-or-die)

  4. [Представление структур данных из функций](https://www.codewars.com/kata/scott-encoding/train/haskell)

     Практически любой тип данных можно представить даже в языке без специальных
     синтаксических конструкций, если этот язык поддерживает функции высшего
     порядка и замыкания. Haskell как раз имеет специальные синтаксические
     конструкции для создания алгебраических типов данных, однако на замену им
     могут прийти простые функции. Как с их помощью сэмулировать пары, Maybe и
     даже списки как раз продемонстрирует эта ката.

     Также для закрепления концепции алгебраических типов данных рекомендую
     подглаву 2.1 книги SICP, там этот подход отлично описан. Саму книгу в целом
     тоже рекомендую в дальнейшем прочесть, хотя многие темы там уже по
     продвинутым темам.

  5. [Изоморфизм (на самом деле довольно простая и интересная ката)](https://www.codewars.com/kata/isomorphism)

- Необязательные для прохождения:

  1. [Алгебраические изоморфизмы (после каты Изоморфизм)](https://www.codewars.com/kata/algebraic-isomorphism/haskell)

  2. [Синглтоны](https://www.codewars.com/kata/54750ed320c64c64e20002e2)

     Несложная ката, решив которую можно познакомиться с зависимыми типами.
     Несмотря на то, что в Хаскеле на данный момент зависимых типов нет,
     последние можно сымитировать при помощи некоторых расширений `ghci` и
     типов-синглтонов - типов, имеющих только одно значение.

  3. [Корутины](https://www.codewars.com/kata/547a77a6b84a1fb8bf000211)

  4. [Lens](https://www.codewars.com/kata/54258ffb430ca2e4b5000239)

  5. [Простой компилятор](https://www.codewars.com/kata/5265b0885fda8eac5900093b)

Обязательно попробуйте найти и пройти еще от 3-х кат (1, 2 или 3 kyu)
самостоятельно.


## Третье задание: бот


Нужно написать эхо-бота, который умеет просто отправлять сообщение от
пользователя ему же в ответ.

Бот должен иметь возможность работать через несколько мессенджеров, пока как
минимум сделать имплементацию для Telegram и для VK:

- Telegram: https://core.telegram.org/bots/api#poll
- VK: https://vk.com/dev/bots_longpoll


### Функциональные требования


1. Пользователь может отправить команду /help и увидеть текст, описывающий бота.

2. Пользователь может отправить команду `/repeat`, и в ответ бот отправит, какое
   сейчас выбрано значение повторов и вопрос, сколько раз повторять сообщение в
   дальнейшем. К вопросу будут прилагаться кнопки для выбора ответа (кнопки с
   цифрами от 1 до 5). После выбора пользователем все ответы бота должны
   дублировать сообщение пользователя указанное кол-во раз. Кол-во повторов
   должно быть индивидуальным для каждого пользователя, т. е. если один
   пользователь выбрал 3 повторения, то второму мы по-прежнему показываем
   начальное кол-во сообщений.

3. Все должно быть максимально кастомизируемо через конфиги

   1. Сообщение, отправляемое в ответ на `/help`.
   2. Вопрос по команде `/repeat`.
   3. Начальное кол-во повторов на каждый ответ.

4. Бот должен уметь повторять только текстовые сообщения и стикеры. Остальные
   виды сообщений можно игнорировать.


### Технические требования


1. Для основного кода проекта (кроме тестов) использовать только библиотеки из
   стандартной поставки Haskell Platform (bytestring, text, mtl etc, [полный
   список](https://www.haskell.org/platform/contents.html)) и три сторонние:

   1. Для отправки http-запросов
   2. Для парсинга json
   3. Для работы с конфигом.

2. Все остальное должно быть сделано по максимуму без библиотек. Для тестов
   можете использовать любой удобный вам инструмент (`hspec`, `HUnit`, etc).

3. Обновления от Телеграма и ВК получать не посредством веб-хуков, а посредством
   поллинга. Отправлять запрос за апдейтами телеграму, тот сам будет ставить
   ответ на паузу, если обновок нет, и отвечать сразу, как только что-то
   появилось. Ну или отвечать пустым массивом по таймауту. Это требование вкупе
   с тем, что в следующем задании надо будет свой сервер на `Warp` реализовать,
   поможет лучше понять, что такое модель поллинга и модель пуша (через
   веб-хуки), в чем преимущества и недостатки каждой из моделей.

4. Боты не обязательно запускать параллельно, а можно определять, какой бот
   запустить, на основе конфига или аргументов запуска программы.


### Следующие технические требования также распространяются и на следующее задание "Веб-сервер"


1. Проект должен быть в отдельном репозитории на github, во время выполнения
   задания коммиты делать как можно чаще, как минимум раз в день, когда написана
   хоть строчка кода.

2. Использовать [stack](https://www.haskellstack.org/), все используемые
   библиотеки должны быть зафиксированы в файле `package.yaml`, сам проект
   должен быть инициирован командой `stack new`, которая создает базовую
   структуру Haskell-проекта.

3. Для разворачивания должно быть достаточно клонирования репозитория и запуска
   `stack build`. Обязательно проверить это правило клонированием репозитория в
   отдельную папку у себя и запуска `stack build` — результатом должны быть
   собранные и рабочие бинарники.

4. У каждого проекта должно быть `README` с описанием того, как разворачивать
   проект локально и как его запускать, а так же с описанием базовой структуры,
   чтобы новичок мог легко разобраться (представьте, что после вас проект будет
   поддерживать совсем нулевой джуниор). Все должно быть на английском.

5. Проект должен иметь файл `.gitignore`, куда внесены все автогенерируемые файлы
   проекта, локальные конфиги и т.д. Обязательно добавьте туда следующие папки
   (даже если вы не пользуетесь редактором VSCode, им пользуемся мы и это
   правило для нашего удобства при проверке):

   - `.vscode`
   - `.history`

6. Проект должен быть покрыт unit-тестами, которые бы покрывали главные use-case
   каждого модуля в приложении.

7. Конфиги должны быть вынесены в отдельный файл с возможностью переписать
   локально какие-нибудь значения, но не изменять файлы из git-репозитория,
   чтобы случайно не запушить пароль или токен.

8. Проект должен поддерживать логи разных уровней, все ключевые моменты должны
   грамотно логироваться, логи должны легко конфигурироваться хотя бы так, чтобы
   можно было включать/выключать логи до определенного уровня (например,
   показывать все от `DEBUG` и выше, или показывать все от `WARN` и выше).

9. Для понятной архитектуры рекомендуем использовать [Handle
   Pattern](https://jaspervdj.be/posts/2018-03-08-handle-pattern.html), так как
   мы применяем его в большинстве своих проектов.

10. Чтобы добиться понятной архитектуры проекта, и получить тестируемый код,
    также можно применять различные техники (паттерны) описанные сообществом:

  - [The Service Pattern](https://www.schoolofhaskell.com/user/meiersi/the-service-pattern)
  - [The ReaderT Design Pattern (Discussion)](https://www.fpcomplete.com/blog/2017/06/readert-design-pattern)
  - [Three Layer Haskell Cake](https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html)

11. Полезно почитать требования к проекту из задания 5 (код-ревью). На старте
    проекта необязательно забивать себе ими голову — потом успеете, но,
    все-таки, если знать их заранее, придется меньше исправлять.

### Источники

* Для начала можно посмотреть [простую
  статью](https://www.bekk.christmas/post/2019/23/making-a-small-haskell-application)
  про то, как начать собирать первое приложение по отправке HTTP-запроса и
  получению одного нужного поля из JSON

* [Designing Testable Components](http://felixmulder.com/writing/2019/10/05/Designing-testable-components.html)

* Полезные статьи для данного задания:

  * https://tproger.ru/translations/telegram-bot-create-and-deploy/amp/ - по поводу бота
  * https://artyom.me/aeson
  * https://ruhaskell.org/posts/packages/2015/02/03/aeson-hello-world.html
  * https://ruhaskell.org/posts/packages/2015/03/05/aeson-next.html


## Четвертое задание: веб-сервер


Создать проект новостей (представим, что это сервер для мобильного приложения).

REST API, который принимает HTTP запросы и отдает ответы в формате JSON.


### Функциональные требования

#### Проект содержит следующие сущности


1. Пользователь

   * Имя
   * Фамилия
   * Аватарка
   * Логин
   * Пароль
   * Дата создания
   * Админ (булевая переменная)

2. Авторы

   * Ссылка на пользователя (то есть все авторы — пользователи, но не все пользователи — авторы)
   * Краткое описание

3. Категории (могут быть вложенными, то есть одна категория является
   подкатегорией для другой).

   Допустим, есть категория "Языки программирования", и у нее может быть
   подкатегория "Динамически Типизированные ЯП", и далее, соответственно,
   подкатегория подкатегории "Python" — и таких уровней вложенности может быть
   произвольное количество.

4. Теги

5. Новости

   * Краткое название
   * Дата создания
   * Один автор
   * Одна категория
   * Множество тегов
   * Текстовый контент
   * Одна главная фотография
   * Множество дополнительных фотографий

6. Комментарий к новости

   * У каждой новости может быть множество комментариев

7. Черновики

   * Новость должна иметь возможность иметь черновики — то есть мы должны иметь возможность вносить изменения, но не опубликовать их.
   * По API отдаем только опубликованные новости.
   * Только автор может видеть черновик к новости и изменять его.


#### API


1. Когда по API запрашиваем новости, в каждой новости должны быть вложены все
   сущности (автор, категория (рекурсивно), теги и т.д.).

2. API новостей должно поддерживать фильтрацию по полям:

   * День создания (созданные ранее даты, созданные после даты, созданные в тот
     же день)

     Примеры:

     - `/posts?created_at=2018-05-21`
     - `/posts?created_at__lt=2018-05-21`
     - `/posts?created_at__gt=2018-05-21`

   * Имя автора
   * Категория по айди
   * Тег по айди

     Примеры:

     - `/posts?tag=123`
     - `/posts?tags__in=[123,124,125]`
     - `/posts?tags__all=[123,124,125]`

   * Поиск по конкретному тегу
   * Найти статьи, в которых есть хоть один тег из списка
   * Найти только те статьи, в которых есть все теги одновременно
   * Название (вхождение подстроки)
   * Контент (вхождение подстроки)

3. API новостей должно поддерживать поиск по строке, которая может быть найдена
   либо в текстовом контенте, либо в имени автора, либо в названии
   категории/тега

4. API новостей должно поддерживать сортировку по:

   * Дате,
   * Автору (имя по алфавиту),
   * По категориям (название по алфавиту),
   * По количеству фотографий

5. Должны быть отдельные API для сущностей:

   * Авторы: и создание, и редактирование, и получение, и удаление, только для админов,
   * Категории: получение всем, создание, удаление и редактирование только для админов,
   * Теги: получение всем, создание, удаление и редактирование только для админов,
   * Черновики: создание, редактирование, получение, удаление всем авторам только своих черновиков, плюс отдельный метод publish, чтобы апдейтнуть публикацию
   * Пользователи: создание, получение всем (редактирования нет), удаление только
     админам

6. Что доступно только админам, при запросе не-админам возвращать 404, а не 403,
   чтобы не показать само наличие такого API.

7. Запросы по всем остальным URL должны возвращать 404.

8. Аутентификация:

   * При создании пользователя генерировать и возвращать токен.
   * Добавить эндпоинт, который будет проводить аутентификацию по логину и паролю
     и будет выдавать новый токен при необходимости. При этом старый токен
     становится недействительным.
   * Аутентификацию в остальном API проводить по токену.
   * Хешировать пароли в базе данных.

9. Все API, возвращающие список данных, должны быть пагинированы.


### Технические требования


1. В качестве веб-сервера под капотом использовать Warp

   Обязательно прочесть описание, как он работает:
   <http://www.aosabook.org/en/posa/warp.html>.

   В целом эту книгу (AOSA Book) очень рекомендуем, там огромное количество
   инсайтов по многим крутым опенсорсным проектам.

   Чтобы использовать Warp, необходимо понимать WAI, так что еще по нему
   прочитать — <https://www.yesodweb.com/book/web-application-interface>.

2. В качестве базы использовать PostgreSQL

3. Можно использовать только библиотеки из Haskell Platform и из следующего
   списка. Возможно, мы что-то забыли добавить в этот список - если у вас
   появилось желание использовать другую библиотеку, обязательно спросите в
   чате. Смысл в том, чтобы самостоятельно поработать с HTTP и базами данных, не
   пользуясь высокоуровневыми прослойками, не понимая, как они работают под
   капотом:

   1. `cryptonite` для хеширования паролей
   2. `warp`
   3. `wai`
   4. библиотека для работы с PostgreSQL
   5. библиотека для чтения конфига

4. Для работы с базой можно использовать любые библиотеки, главное — самим
   создавать и поддерживать миграции. В идеале, в готовом проекте по миграциям
   должна прослеживаться история изменения таблиц в процессе разработки - то
   есть дожна быть не только инициализирующая миграция (разве что вы сразу всё
   красиво спроектировали:)), но и миграции для добавления новых таблиц,
   изменения названий и типов полей и т.д.

   Миграции — код, который задает структуру базе (то есть создание таблиц,
   изменение, переименование, удаление полей и тд).

   Обязательно держите в голове, что после того, как проект выпускается в
   продакшен, база на проде заполняется данными, которые ни в коем случае нельзя
   потерять. Но требование менять структуру базы регулярно появляется за время
   развития проекта, и надо уметь развивать базу без потери данных. Для этого
   нужно как можно тщательней формализовать все изменения, которые вы проводите
   над базой от версии к версии.

5. Должна быть предоставлена отдельная команда, которая позволит применить все
   миграции к локальной базе данных и создать всю нужную структуру для бд.

6. В отдельной папке проекта сделать sh-скрипты со всеми возможными
   CURL-запросами, чтобы мы могли быстро склонировать проект и потестить его.
   Сделать по sh-файлу на каждый CURL-запрос.

7. Также следовать общим правилам, описанным в прошлом задании.


### Источники


[Lessons learned while writing a Haskell
application](https://gvolpe.github.io/blog/lessons-learned-while-writing-a-haskell-app/)
— не всем рекомендациям отсюда мы бы советовали следовать, но почитать про
релевантный опыт автора статьи будет однозначно полезно.


## Пятое задание: ревью


В рамках этого этапа наши сотрудники проведут строгое ревью github-репозиториев
для предыдущих двух проектов: бота и веб-сервера.

1. Прежде чем приступить к этому этапу, отправьте свои репозитории нам для
   проверки через вот эту
   [форму](https://fullstack-dev.typeform.com/to/Q4FDE0ge) заявки на ревью
   проектов. Только получив эту форму, мы начнем проверку :)

2. После прохождения вами этапа код-ревью напишите менеджеру программы обучения
   в личные сообщения в телеграмме.

Проверка кода в рамках ревью будет не только на предмет формальных требований
ниже, но и на предмет продуманной и ясной архитектуры, читаемого и понятного
кода, удобного интерфейса работы с вашими функциями. Код пройдет проверку только
тогда, когда будет настолько хорош, чтобы мы сами не боялись брать его на
поддержку :) Конечно, ровно эти же правила затем будут применяться и при всех
ревью уже на реальных проектах после приема на работу.


### Требования к оформлению проекта


1. Весь проект скомпилирован с флагами `-Wall` и `-Werror` и нет ни одной ошибки и ни одного варнинга от компилятора.
2. Весь код проверен через `hlint` и не вызывает ни одного варнинга.
3. Весь код отформатирован при помощи форматтера `ormolu`.
4. Все импорты либо qualified, либо содержат явный import list.
5. Не используются нетотальные функции (Partial functions).
6. Вложенность условных операторов и операторов выбора не превышает 2 уровней.
7. Не используются длинные кортежи, когда удобнее использовать ADT.
8. Ошибки внимательно обрабатываются и не глушатся:
   * https://wiki.haskell.org/Handling_errors_in_Haskell
   * https://wiki.haskell.org/Error_reporting_strategies
   * https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell
9. Не используются `error` и `undefined`.
10. Названия функций выбраны в соответствии с проблемой, которую эти функции решают.
11. Каждая функция решает только одну проблему.
12. Использовать паттерны проектирования: Service/Handle Pattern или Tagless Final/ReaderT.
13. Основной функционал должен быть покрыт чистыми юнит-тестами. E2E тесты в рамках программы обучения писать не требуется.
14. Проект должен запускаться и работать с конфигом проверяющего (например, чтобы можно было проверить работу бота с другим токеном).
15. Все изменения в проект в процессе код-ревью вносите через пулл-реквесты. В ПР указывайте ссылку на ишью.


### Рекомендуемые источники по оформлению кода


* https://wiki.haskell.org/Programming_guidelines (правила про Haddock можно
  игнорировать)

* https://wiki.haskell.org/Things_to_avoid

* https://wiki.haskell.org/Avoiding_IO

* HaskellerZ - Feb 2018 - Getting things done in Haskell and Zurich Friends of
  Haskell

  https://www.youtube.com/watch?v=-X1vrxQUETM — смотреть первую часть до 51
  минуты, там идет набор разных правил по разработке на Хаскеле. Паттерн Handle
  стоит рассмотреть, но необязательно применять.

  Слайды:
  https://github.com/jaspervdj/talks/blob/master/2018-haskellerz-getting-things-done/slides.md

  Обязательно изучить репозиторий, который там есть в ссылке, там то приложение,
  о котором рассказывал спикер: Fugacious.


## Интервью по теоретическим вопросам


В [нашем репозитории с картой
развития](https://github.com/fullstack-development/developers-roadmap/tree/master/backend/junior-1)
у нас подготовлены около 80 вопросов по материалам из пройденных вами заданий.
Там мы проверяем, что вы действительно изучили весь тот материал, помогаем вам
побороть [неосознанную некомпетентность](http://sergeykorol.ru/blog/competence/)
через получение обратной связи от нас.

Сами вопросы вы можете посмотреть в [нашем репозитории на Github (папка
junior-1)](https://github.com/fullstack-development/developers-roadmap/tree/master/backend/junior-1).

Количество попыток на сдачу не ограничено, обычно уходит неделя-две, чтобы
повторить изученное и ещё неделя на две-три попытки сдачи, после чего задание
успешно завершается. В рамках этого шага вы действительно систематизируете все
полученные знания, закрываются дыры в знаниях, которые почти наверняка у вас
будут, обычно это один из самых эффективных этапов в обучении, когда каждый день
на уже крепкую основу ваших знаний укладывается огромное количество нового и
полезного материала.
