# Четвертое задание: веб-сервер


Создать проект новостей (представим, что это сервер для мобильного приложения).

REST API, который принимает HTTP запросы и отдает ответы в формате JSON.


## Функциональные требования

### Проект содержит следующие сущности


1. Пользователь

   * Имя
   * Фамилия
   * Аватарка
   * Логин
   * Пароль
   * Дата создания
   * Админ (булевая переменная)

2. Авторы

   * Ссылка на пользователя (то есть все авторы — пользователи, но не все пользователи — авторы)
   * Краткое описание

3. Категории (могут быть вложенными, то есть одна категория является
   подкатегорией для другой).

   Допустим, есть категория "Языки программирования", и у нее может быть
   подкатегория "Динамически Типизированные ЯП", и далее, соответственно,
   подкатегория подкатегории "Python" — и таких уровней вложенности может быть
   произвольное количество.

4. Теги

5. Новости

   * Краткое название
   * Дата создания
   * Один автор
   * Одна категория
   * Множество тегов
   * Текстовый контент
   * Одна главная фотография
   * Множество дополнительных фотографий

6. Комментарий к новости

   * У каждой новости может быть множество комментариев

7. Черновики

   * Новость должна иметь возможность иметь черновики — то есть мы должны иметь возможность вносить изменения, но не опубликовать их.
   * По API отдаем только опубликованные новости.
   * Только автор может видеть черновик к новости и изменять его.


### API


1. Когда по API запрашиваем новости, в каждой новости должны быть вложены все
   сущности (автор, категория (рекурсивно), теги и т.д.).

2. API новостей должно поддерживать фильтрацию по полям:

   * День создания (созданные ранее даты, созданные после даты, созданные в тот
     же день)

     Примеры:

     - `/posts?created_at=2018-05-21`
     - `/posts?created_at__lt=2018-05-21`
     - `/posts?created_at__gt=2018-05-21`

   * Имя автора
   * Категория по айди
   * Тег по айди

     Примеры:

     - `/posts?tag=123`
     - `/posts?tags__in=[123,124,125]`
     - `/posts?tags__all=[123,124,125]`

   * Поиск по конкретному тегу
   * Найти статьи, в которых есть хоть один тег из списка
   * Найти только те статьи, в которых есть все теги одновременно
   * Название (вхождение подстроки)
   * Контент (вхождение подстроки)

3. API новостей должно поддерживать поиск по строке, которая может быть найдена
   либо в текстовом контенте, либо в имени автора, либо в названии
   категории/тега

4. API новостей должно поддерживать сортировку по:

   * Дате,
   * Автору (имя по алфавиту),
   * По категориям (название по алфавиту),
   * По количеству фотографий

5. Должны быть отдельные API для сущностей:

   * Авторы: и создание, и редактирование, и получение, и удаление, только для админов,
   * Категории: получение всем, создание, удаление и редактирование только для админов,
   * Теги: получение всем, создание, удаление и редактирование только для админов,
   * Черновики: создание, редактирование, получение, удаление всем авторам только своих черновиков, плюс отдельный метод publish, чтобы апдейтнуть публикацию
   * Пользователи: создание, получение всем (редактирования нет), удаление только
     админам

6. Что доступно только админам, при запросе не-админам возвращать 404, а не 403,
   чтобы не показать само наличие такого API.

7. Запросы по всем остальным URL должны возвращать 404.

8. Аутентификация:

   * При создании пользователя генерировать и возвращать токен.
   * Добавить эндпоинт, который будет проводить аутентификацию по логину и паролю
     и будет выдавать новый токен при необходимости. При этом старый токен
     становится недействительным.
   * Аутентификацию в остальном API проводить по токену.
   * Хешировать пароли в базе данных.

9. Все API, возвращающие список данных, должны быть пагинированы.


## Технические требования


1. В качестве веб-сервера под капотом использовать Warp

   Обязательно прочесть описание, как он работает:
   <http://www.aosabook.org/en/posa/warp.html>.

   В целом эту книгу (AOSA Book) очень рекомендуем, там огромное количество
   инсайтов по многим крутым опенсорсным проектам.

   Чтобы использовать Warp, необходимо понимать WAI, так что еще по нему
   прочитать — <https://www.yesodweb.com/book/web-application-interface>.

2. В качестве базы использовать PostgreSQL

3. Можно использовать только библиотеки из Haskell Platform и из следующего
   списка. Возможно, мы что-то забыли добавить в этот список - если у вас
   появилось желание использовать другую библиотеку, обязательно спросите в
   чате. Смысл в том, чтобы самостоятельно поработать с HTTP и базами данных, не
   пользуясь высокоуровневыми прослойками, не понимая, как они работают под
   капотом:

   1. `cryptonite` для хеширования паролей
   2. `warp`
   3. `wai`
   4. библиотека для работы с PostgreSQL
   5. библиотека для чтения конфига

4. Для работы с базой можно использовать любые библиотеки, главное — самим
   создавать и поддерживать миграции. В идеале, в готовом проекте по миграциям
   должна прослеживаться история изменения таблиц в процессе разработки - то
   есть дожна быть не только инициализирующая миграция (разве что вы сразу всё
   красиво спроектировали:)), но и миграции для добавления новых таблиц,
   изменения названий и типов полей и т.д.

   Миграции — код, который задает структуру базе (то есть создание таблиц,
   изменение, переименование, удаление полей и тд).

   Обязательно держите в голове, что после того, как проект выпускается в
   продакшен, база на проде заполняется данными, которые ни в коем случае нельзя
   потерять. Но требование менять структуру базы регулярно появляется за время
   развития проекта, и надо уметь развивать базу без потери данных. Для этого
   нужно как можно тщательней формализовать все изменения, которые вы проводите
   над базой от версии к версии.

5. Должна быть предоставлена отдельная команда, которая позволит применить все
   миграции к локальной базе данных и создать всю нужную структуру для бд.

6. В отдельной папке проекта сделать sh-скрипты со всеми возможными
   CURL-запросами, чтобы мы могли быстро склонировать проект и потестить его.
   Сделать по sh-файлу на каждый CURL-запрос.

7. Также следовать общим правилам, описанным в прошлом задании.


## Источники


[Lessons learned while writing a Haskell
application](https://gvolpe.github.io/blog/lessons-learned-while-writing-a-haskell-app/)
— не всем рекомендациям отсюда мы бы советовали следовать, но почитать про
релевантный опыт автора статьи будет однозначно полезно.


